using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

namespace Layout
{
    public class HexLayout : MonoBehaviour
    {
        #region Exposed fields

        #endregion Exposed fields

        #region Internal fields

        [SerializeField]
        float hexWidth;

        [SerializeField]
        float hexHeight;

        [SerializeField]
        float spacing;

        [SerializeField]
        bool preserveScale = true;

        [SerializeField]
        List<Tile> tilePrefabs;

        [SerializeField]
        Mesh tilePreviewMesh;

        [SerializeField]
        Pathfinder pathfinder;

        [SerializeField]
        bool debug;

        #endregion Internal fields

        // Example data that should be loaded from a file generated by a map editor or procedural generator
        private int[,] tileInfo = new int[,]
        {
        {0,0,2,4,2,3,3,2},
        {0,0,0,1,2,1,3,1},
        {0,1,0,2,2,3,0,2},
        {0,1,4,1,3,1,0,0},
        {4,4,4,1,3,1,2,0},
        {1,1,0,2,4,4,2,4},
        {2,1,3,1,1,2,4,4},
        {3,3,3,1,2,1,2,4}
        };

        private Tile[,] tiles;

        private Vector3 StartPos => transform.position;

        private Dictionary<Hex, Tile> tilesDictionary = new Dictionary<Hex, Tile>();

        private List<Tile> highlightedTiles = new List<Tile>();
        private List<Tile> pathTiles = new List<Tile>();

        #region Properties

        public Dictionary<Hex, Tile> TilesDictionary => tilesDictionary;

        #endregion Properties

        #region Custom Events

        #endregion Custom Events

        #region Events methods

        private void Awake()
        {
            GenerateTiles();
        }

        private void Update()
        {
            UpdateTiles();
        }

        #endregion Events methods

        #region Public Methods

        public void GenerateTiles()
        {
            if (tileInfo == null)
            {
                return;
            }

            tiles = new Tile[tileInfo.GetLength(0), tileInfo.GetLength(1)];
            tilesDictionary.Clear();

            for (var j = 0; j < tileInfo.GetLength(1); j++)
            {
                for (var i = 0; i < tileInfo.GetLength(0); i++)
                {
                    try
                    {
                        var type = tileInfo[i, j];
                        type = Mathf.Clamp(type, 0, tilePrefabs.Count);
                        var tile = Instantiate(tilePrefabs[type], transform);

                        tile.SetLayout(this);
                        tile.SetCoords(i, j);

                        // To find tiles by hex much faster
                        tilesDictionary.Add(tile.Hex, tile);

                        tile.transform.position = GridToWorldPos(i, j);
                        tile.OnPointerEnter.AddListener(pathfinder.OnTileEntered);
                        tile.OnPointerClick.AddListener(pathfinder.OnTileClicked);

                        if (!preserveScale) tile.transform.localScale = new Vector3(hexWidth, (hexWidth + hexHeight) / 2f, hexHeight);

                        tiles[i, j] = tile;
                    }
                    catch (Exception ex)
                    {
                        Debug.LogException(ex);
                    }
                }
            }

            DoForEach(tile => tile.CacheNeighbors());
        }

        public void UpdateTiles()
        {
            if (tiles == null)
            {
                GenerateTiles();
                return;
            }

            for (var i = 0; i < tiles.GetLength(0); i++)
            {
                for (var j = 0; j < tiles.GetLength(1); j++)
                {
                    tiles[i, j].transform.position = GridToWorldPos(i, j);
                    if (!preserveScale) tiles[i, j].transform.localScale = new Vector3(hexWidth, (hexWidth + hexHeight) / 2f, hexHeight);
                }
            }
        }

        public void DoForEach(Action<Tile> action)
        {
            if (tiles == null || action == null) return;

            for (var i = 0; i < tiles.GetLength(0); i++)
            {
                for (var j = 0; j < tiles.GetLength(1); j++)
                {
                    action?.Invoke(tiles[i, j]);
                }
            }
        }

        public Vector3 GridToWorldPos(int i, int j)
        {
            float offset = i % 2 == 0 ? 0 : hexWidth / 2 + spacing / 2;
            float x = StartPos.x + offset + j * (hexWidth + spacing);
            float y = StartPos.y;
            float z = StartPos.z - i * (hexHeight * 0.75f + spacing);
            return new Vector3(x, y, z);
        }

        public Tile GetTileByHex(Hex hex)
        {
            return tilesDictionary[hex];
        }

        public void Highlight(Tile tile)
        {
            highlightedTiles.Clear();
            highlightedTiles.Add(tile);
            // var neighborHexes = tile.Hex.Neighbors();
            // foreach (Tile neighbor in tile.Neighbours)
            // {
            //     if (neighbor) highlightedTiles.Add(neighbor);
            // }
        }

        public void SetPathTiles(List<Tile> tiles)
        {
            if (tiles == null) return;
            Debug.Log(tiles.Count);
            pathTiles.Clear();
            pathTiles = tiles;
        }

        #endregion Public Methods

        #region Non Public Methods

        private void OnDrawGizmos()
        {
            Gizmos.color = Color.black * 0.5f;

            foreach (var tile in highlightedTiles)
            {
                Gizmos.DrawMesh(tilePreviewMesh, default, tile.transform.position, tile.transform.rotation, tile.transform.localScale * 1.2f);
            }

            if (Application.isPlaying) return;

            var width = 8;
            var height = 8;

            if (tileInfo != null)
            {
                width = tileInfo.GetLength(0);
                height = tileInfo.GetLength(1);
            }

            Gizmos.color = Color.blue * 0.8f;

            for (var i = 0; i < width; i++)
            {
                for (var j = 0; j < height; j++)
                {
                    var pos = GridToWorldPos(i, j);
                    var scale = Vector3.one;
                    if (!preserveScale) scale = new Vector3(hexWidth, (hexWidth + hexHeight) / 2f, hexHeight);
                    Gizmos.DrawMesh(tilePreviewMesh, default, pos, Quaternion.identity, scale);
                }
            }
        }

        #endregion Non Public Methods
    }
}
