using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

namespace Layout
{
    public class HexLayout : MonoBehaviour
    {
        #region Exposed fields

        #endregion Exposed fields

        #region Internal fields

        /// <summary>
        /// The width in world scale of each hex tile
        /// </summary>
        [SerializeField]
        float hexWidth;

        /// <summary>
        /// The height in world scale of each hex tile
        /// </summary>
        [SerializeField]
        float hexHeight;

        /// <summary>
        /// The space between each tile
        /// </summary>
        [SerializeField]
        float spacing;

        /// <summary>
        /// If false, tiles are stretched to match width and height
        /// </summary>
        [SerializeField]
        bool preserveScale = true;

        /// <summary>
        /// The tile prefabs to use when generating the map
        /// </summary>
        [SerializeField]
        List<Tile> tilePrefabs;

        /// <summary>
        /// Mesh to use when previewing the hex layout in the editor
        /// </summary>
        [SerializeField]
        Mesh tilePreviewMesh;

        /// <summary>
        /// Attached pathfinder
        /// </summary>
        [SerializeField]
        Pathfinder pathfinder;

        #endregion Internal fields

        /// <summary>
        /// Example data that should be loaded from a file generated by a map editor or procedural generator
        /// </summary>
        /// <value></value>
        private int[,] tileInfo = new int[,]
        {
        {0,0,2,4,2,3,3,2},
        {0,0,0,1,2,1,3,1},
        {0,1,0,2,2,3,0,2},
        {0,1,4,1,3,1,0,0},
        {4,4,4,1,3,1,2,0},
        {1,1,0,2,4,4,2,4},
        {2,1,3,1,1,2,4,4},
        {3,3,3,1,2,1,2,4}
        };

        private Tile[,] tiles;

        private Vector3 StartPos => transform.position;

        private Dictionary<Hex, Tile> tilesDictionary = new Dictionary<Hex, Tile>();

        private List<Tile> highlightedTiles = new List<Tile>();

        #region Properties

        public Dictionary<Hex, Tile> TilesDictionary => tilesDictionary;

        #endregion Properties

        #region Custom Events

        #endregion Custom Events

        #region Events methods

        private void Awake()
        {
            GenerateTiles();
        }

        private void Update()
        {
            UpdateTiles();
        }

        #endregion Events methods

        #region Public Methods

        /// <summary>
        /// Generates map tiles if not already generated
        /// </summary>
        public void GenerateTiles()
        {
            if (tileInfo == null)
            {
                return;
            }

            tiles = new Tile[tileInfo.GetLength(0), tileInfo.GetLength(1)];
            tilesDictionary.Clear();

            for (var j = 0; j < tileInfo.GetLength(1); j++)
            {
                for (var i = 0; i < tileInfo.GetLength(0); i++)
                {
                    try
                    {
                        var type = tileInfo[i, j];
                        type = Mathf.Clamp(type, 0, tilePrefabs.Count);
                        var tile = Instantiate(tilePrefabs[type], transform);

                        tile.SetLayout(this);
                        tile.SetCoords(i, j);

                        // To find tiles by hex much faster
                        tilesDictionary.Add(tile.Hex, tile);

                        tile.transform.position = GridToWorldPos(i, j);
                        tile.OnPointerEnter.AddListener(pathfinder.OnTileEntered);
                        tile.OnPointerEnter.AddListener(Highlight);
                        tile.OnPointerClick.AddListener(pathfinder.OnTileClicked);

                        if (!preserveScale) tile.transform.localScale = new Vector3(hexWidth, (hexWidth + hexHeight) / 2f, hexHeight);

                        tiles[i, j] = tile;
                    }
                    catch (Exception ex)
                    {
                        Debug.LogException(ex);
                    }
                }
            }

            DoForEach(tile => tile.CacheNeighbors());
        }

        /// <summary>
        /// Updates map tiles or generates them if not generated
        /// </summary>
        public void UpdateTiles()
        {
            if (tiles == null)
            {
                GenerateTiles();
                return;
            }

            for (var i = 0; i < tiles.GetLength(0); i++)
            {
                for (var j = 0; j < tiles.GetLength(1); j++)
                {
                    tiles[i, j].transform.position = GridToWorldPos(i, j);
                    if (!preserveScale) tiles[i, j].transform.localScale = new Vector3(hexWidth, (hexWidth + hexHeight) / 2f, hexHeight);
                }
            }
        }

        /// <summary>
        /// Perform given action on each tile
        /// </summary>
        /// <param name="action"></param>
        public void DoForEach(Action<Tile> action)
        {
            if (tiles == null || action == null) return;

            for (var i = 0; i < tiles.GetLength(0); i++)
            {
                for (var j = 0; j < tiles.GetLength(1); j++)
                {
                    action?.Invoke(tiles[i, j]);
                }
            }
        }

        /// <summary>
        /// Transforms grid coordinates into real world coordinates
        /// </summary>
        /// <param name="i">Row</param>
        /// <param name="j">Column</param>
        /// <returns>Returns world coordinates in Vector3 form</returns>
        public Vector3 GridToWorldPos(int i, int j)
        {
            float offset = i % 2 == 0 ? 0 : hexWidth / 2 + spacing / 2;
            float x = StartPos.x + offset + j * (hexWidth + spacing);
            float y = StartPos.y;
            float z = StartPos.z - i * (hexHeight * 0.75f + spacing);
            return new Vector3(x, y, z);
        }

        /// <summary>
        /// Get tile with given hex
        /// </summary>
        /// <param name="hex"></param>
        /// <returns>Returns tile with given hex</returns>
        public Tile GetTileByHex(Hex hex)
        {
            return tilesDictionary[hex];
        }

        /// <summary>
        /// Highlight given tile
        /// </summary>
        /// <param name="tile"></param>
        public void Highlight(Tile tile)
        {
            highlightedTiles.Clear();
            highlightedTiles.Add(tile);
        }

        #endregion Public Methods

        #region Non Public Methods
        
        private void OnDrawGizmos()
        {
            Gizmos.color = Color.black * 0.5f;

            foreach (var tile in highlightedTiles)
            {
                Gizmos.DrawMesh(tilePreviewMesh, default, tile.transform.position, tile.transform.rotation, tile.transform.localScale * 1.2f);
            }

            if (Application.isPlaying) return;

            var width = 8;
            var height = 8;

            if (tileInfo != null)
            {
                width = tileInfo.GetLength(0);
                height = tileInfo.GetLength(1);
            }

            Gizmos.color = Color.blue * 0.8f;

            for (var i = 0; i < width; i++)
            {
                for (var j = 0; j < height; j++)
                {
                    var pos = GridToWorldPos(i, j);
                    var scale = Vector3.one;
                    if (!preserveScale) scale = new Vector3(hexWidth, (hexWidth + hexHeight) / 2f, hexHeight);
                    Gizmos.DrawMesh(tilePreviewMesh, default, pos, Quaternion.identity, scale);
                }
            }
        }

        #endregion Non Public Methods
    }
}
